# アセンブリ番号領域検出 PoC - 最終レポート

## 実装アプローチ
**ルールベース（サイズ・面積フィルタ）**
- OCRや重いAIライブラリを使用せず、OpenCVのみで実装
- 赤枠・黒枠を検出し、サイズ・面積でフィルタリング
- 重複領域をマージして最終的なアセンブリ番号領域を決定

## 最終検出結果

| ファイル名 | 正解数 | 検出数 | 精度 | 評価 |
|------------|--------|--------|------|------|
| パンターG型_001.jpg | 2 | 2 | 100% | ✅ **完璧** |
| パンターG型_002.jpg | 2 | 3 | 67% | △ 誤検出+1 |
| パンターG型_003.jpg | 3 | 4 | 75% | △ 誤検出+1 |
| パンターG型_004.jpg | 2 | 3 | 67% | △ 誤検出+1 |
| パンターG型_005.jpg | 6 | 5 | 83% | △ 検出漏れ-1 |

**平均精度**: 78.4%

## 試行した改善策

### 1. サイズ・面積フィルタの最適化 ✅
- 最小サイズ: 画像短辺の10%
- 最小面積: 画像全体の1%
- アスペクト比: 8以下

**効果**: 誤検出を大幅に削減（例: 005が12個→5個）

### 2. 「xN」パターンマッチング ❌
- 部品リスト内の「x1」「x2」表記を検出
- 文字領域の検出が不安定で、一部の画像で全く機能せず

**結論**: 不採用（サイズフィルタのみの方が安定）

## 技術的成果

### 成功した点
1. **軽量実装**: OpenCVのみで動作、追加ライブラリ不要
2. **環境非依存**: Windows/WSL/Linux本番環境で同じコードが動作
3. **実用的精度**: 001は完璧、他も70%以上の精度
4. **誤検出削減**: 初期の13個→最終5個（005の例）

### 残る課題
1. **誤検出**: 002, 003, 004で各1個ずつ余分な領域を検出
2. **検出漏れ**: 005で1個の領域を見逃し

## 実運用への推奨事項

### 前提: 半自動フロー
このPoCの精度（78%）は、**完全自動化には不十分**ですが、**半自動フロー**なら十分実用的です。

### 推奨フロー
1. **自動検出**: 本PoCのロジックで初期検出
2. **結果表示**: 検出された領域を画面上に枠で表示
3. **人間による調整**:
   - 誤検出の枠を削除
   - 検出漏れの領域を手動で追加
   - 枠の位置・サイズを微調整
4. **確定・保存**: 調整後の領域を保存

### メリット
- 完全手動より**大幅に作業時間短縮**（6個の領域を1から指定 → 5個は自動検出済み、1個だけ追加）
- 100%の精度を人間が保証できる
- システムの複雑さを抑えられる

## 次のステップ

### Phase 2: Streamlit管理ツールへの統合
1. `apps/admin-tool/src/utils/image_processing.py` の `extract_assembly_numbers` 関数を、本PoCのロジックで置き換え
2. 検出結果を表示するUI実装（枠の描画）
3. 枠の調整機能実装（追加・削除・リサイズ）

### 将来的な改善（オプション）
- **OCR導入**: Tesseractで数字を検出し、フィルタリング精度向上
- **機械学習**: 正解データを蓄積し、YOLOなどで学習（長期的）

## 結論
ルールベースのアプローチで、実用的なレベルの検出精度（78%）を達成しました。
完全自動化は困難ですが、**半自動フロー**を前提とすれば、十分に業務効率化に貢献できます。

次は、このロジックをStreamlit管理ツールに統合し、実際の製品登録フローで使えるようにすることを推奨します。
